<!DOCTYPE html>
<!-- saved from url=(0047)https://juejin.im/post/5d1d465051882579df4a4745 -->
<html lang="zh-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"><meta name="google-site-verification" content="cCHsgG9ktuCTgWgYfqCJql8AeR4gAne4DTZqztPoirE"><meta name="google-site-verification" content="nPvn9R5NJLsZKTv5VKIbn0OmkRcJ4PC6KdDoTX3n5Mw"><meta name="apple-itunes-app" content="app-id=987739104"><meta name="baidu-site-verification" content="qiK2a1kcFc"><meta name="360-site-verification" content="4c3c7d57d59f0e1a308462fbc7fd7e51"><meta name="sogou_site_verification" content="c49WUDZczQ"><style>body {
        font-size: 16px;
        line-height: 2;
      }
      a, button, input {
        margin: 1rem 1.5rem;
      }
      img {
        width: 0;
        height: 0;
      }
      #juejin {
        overflow-x: hidden;
      }</style><meta data-vue-meta="true" data-vmid="keywords" name="keywords" content="编程语言"><meta data-vue-meta="true" data-vmid="description" name="description" content="大家都知道函数调用是通过栈来实现的，而且知道在栈中存放着该函数的局部变量。但是对于栈的实现细节可能不一定清楚。本文将介绍一下在Linux平台下函数栈是如何实现的。有些同学可能觉得没必要了解这么深入，其实非也。根据本号多年的经验，了解系统深层次的原理对分析疑难问"><title data-vue-meta="true">程序员必备高级技术之函数调用栈 - 掘金</title><link rel="apple-touch-icon" sizes="180x180" href="https://b-gold-cdn.xitu.io/favicons/v2/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-16x16.png"><link rel="manifest" href="https://b-gold-cdn.xitu.io/favicons/v2/manifest.json"><link rel="mask-icon" href="https://b-gold-cdn.xitu.io/favicons/v2/safari-pinned-tab.svg" color="#5bbad5"><link rel="shortcut icon" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon.ico"><meta name="msapplication-config" content="https://b-gold-cdn.xitu.io/favicons/v2/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="search" title="掘金" href="https://b-gold-cdn.xitu.io/conf/search.xml" type="application/opensearchdescription+xml"><link rel="stylesheet" href="./程序员必备高级技术之函数调用栈_files/ionicons.min.css"><link rel="stylesheet" href="./程序员必备高级技术之函数调用栈_files/iconfont.css"><link href="./程序员必备高级技术之函数调用栈_files/0.f1fc61eda29199ce1f45.css" rel="stylesheet"><script async="" src="./程序员必备高级技术之函数调用栈_files/hm.js"></script><script async="" src="./程序员必备高级技术之函数调用栈_files/analytics.js"></script><script type="text/javascript" async="" src="./程序员必备高级技术之函数调用栈_files/vds.js"></script><script type="text/javascript" async="" src="./程序员必备高级技术之函数调用栈_files/collect-v.3.2.14.js"></script><script charset="utf-8" src="./程序员必备高级技术之函数调用栈_files/4.281438b56343cf12fa0b.js"></script></head><body><div id="juejin" data-v-2a21baac=""><div class="global-component-box" data-v-2a21baac=""><!----><div data-v-5ef5fb43="" data-v-2a21baac="" class="alert-list alert-list"></div><div data-v-15608c17="" data-v-2a21baac="" class="suspension-panel suspension-panel"><button data-v-15608c17="" title="回到顶部" class="btn to-top-btn" style="display: none;"><i data-v-15608c17="" class="ion-android-arrow-dropup"></i></button><button data-v-15608c17="" title="建议反馈" class="btn meiqia-btn" style=""><i data-v-15608c17="" class="ion-chatbubble-working"></i></button></div><!----><!----><div class="emoji-barrage" data-v-94fd086c="" data-v-2a21baac=""><!----></div><div class="book-new-user-award-popup" style="display:none;" data-v-22fa60e5="" data-v-2a21baac=""><div class="content-box" style="display:;" data-v-22fa60e5=""><div class="close ion-close-round" data-v-22fa60e5=""></div><div class="header" data-v-22fa60e5=""><div class="icon" data-v-22fa60e5=""><img src="./程序员必备高级技术之函数调用栈_files/icon.a87e5ae.svg" data-v-22fa60e5=""></div><div class="txt" data-v-22fa60e5="">新人专享好礼</div></div><div class="desc" data-v-22fa60e5="">凡未购买过小册的用户，均可领取三张 5 折新人专享券，购买小册时自动使用专享券，最高可节省 45 元。</div><div class="tickets" data-v-22fa60e5=""><div class="ticket" data-v-22fa60e5=""><div class="ticket__inner" data-v-22fa60e5=""><div class="enjoy" data-v-22fa60e5=""><span class="new-title" data-v-22fa60e5="">小册新人 5 折券</span></div><div class="sale" data-v-22fa60e5="">最高可省 15 元</div></div></div><div class="ticket" data-v-22fa60e5=""><div class="ticket__inner" data-v-22fa60e5=""><div class="enjoy" data-v-22fa60e5=""><span class="new-title" data-v-22fa60e5="">小册新人 5 折券</span></div><div class="sale" data-v-22fa60e5="">最高可省 15 元</div></div></div><div class="ticket" data-v-22fa60e5=""><div class="ticket__inner" data-v-22fa60e5=""><div class="enjoy" data-v-22fa60e5=""><span class="new-title" data-v-22fa60e5="">小册新人 5 折券</span></div><div class="sale" data-v-22fa60e5="">最高可省 15 元</div></div></div></div><div class="remark" data-v-22fa60e5="">注：专享券的使用期限在领券的七天内。</div><div class="submit-btn" data-v-22fa60e5="">一键领取</div></div><div class="model success" style="display:none;" data-v-22fa60e5=""><div class="heading" data-v-22fa60e5="">领取成功</div><div class="content-text" data-v-22fa60e5="">购买小册时自动使用专享券</div><div class="btn-success-footer" data-v-22fa60e5=""><div class="btn-ok" data-v-22fa60e5="">知道了</div><div class="btn-ok btn-link" data-v-22fa60e5="">前往小册首页</div></div></div><div class="model fail" style="display:none;" data-v-22fa60e5=""><div class="heading" data-v-22fa60e5="">领取失败</div><div class="content-text" data-v-22fa60e5="">本活动仅适用于小册新用户</div><div class="btn-ok" data-v-22fa60e5="">知道了</div></div></div><!----><!----><div class="bind-phone-number-modal-box" data-v-269c0ad0="" data-v-2a21baac=""><div st:block="bindPhoneNumberModal" class="modal-mask" style="display:none;" data-v-269c0ad0=""></div><form class="bind-phone-number-form" style="display:none;" data-v-269c0ad0=""><i title="关闭" class="close-btn ion-close-round" data-v-269c0ad0=""></i><h1 class="title" data-v-269c0ad0="">提示</h1><h2 class="hint" data-v-269c0ad0="">根据我国<a href="http://www.cac.gov.cn/2017-08/25/c_1121541842.htm" target="_blank" style="color:#007fff">《互联网跟帖评论服务管理规定》</a>，您需要绑定手机号后才可在掘金社区内发布内容。</h2><div class="input-group" data-v-269c0ad0=""><div class="input-box" data-v-269c0ad0=""><input maxlength="64" placeholder="请输入要绑定的手机号码" value="" class="input" data-v-269c0ad0=""></div><!----><!----></div><button st:name="bindBtn" class="btn" data-v-269c0ad0="">绑定手机</button></form></div></div><!----><div data-v-6fdc8784="" data-v-fa2339b8="" data-v-2a21baac="" class="view-container"><main data-v-6fdc8784="" class="container main-container"><div data-v-fa2339b8="" data-v-6fdc8784="" class="view column-view"><div data-v-fa2339b8="" data-v-6fdc8784="" class="main-area article-area shadow"><article data-v-fa2339b8="" itemscope="itemscope" itemtype="http://schema.org/Article" class="article" data-v-6fdc8784=""><meta itemprop="url" content="https://juejin.im/post/5d1d465051882579df4a4745"><meta itemprop="headline" content="程序员必备高级技术之函数调用栈"><meta itemprop="keywords" content="编程语言"><meta itemprop="datePublished" content="2019-07-04T00:21:27.490Z"><meta itemprop="image" content="https://b-gold-cdn.xitu.io/icon/icon-128.png"><div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SunnyZhang的IT世界"><meta itemprop="url" content="https://juejin.im/user/5c235146f265da615d72b0f0"></div><div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"><div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://b-gold-cdn.xitu.io/icon/icon-white-180.png"><meta itemprop="width" content="180"><meta itemprop="height" content="180"></div></div><div data-v-fa2339b8="" class="author-info-block"><a data-v-fa2339b8="" href="https://juejin.im/user/5c235146f265da615d72b0f0" target="_blank" rel="" class="avatar-link"><div data-v-95ddf8f6="" data-v-39db9419="" data-v-fa2339b8="" data-src="https://mirror-gold-cdn.xitu.io/168e097b049d23e6838?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1" class="lazy avatar avatar loaded" style="background-image: url(&quot;https://mirror-gold-cdn.xitu.io/168e097b049d23e6838?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1&quot;);"></div></a><div data-v-fa2339b8="" class="author-info-box"><a data-v-263f3a32="" data-v-fa2339b8="" href="https://juejin.im/user/5c235146f265da615d72b0f0" target="_blank" rel="" class="username username ellipsis">SunnyZhang的IT世界<a data-v-6d94a6ea="" data-v-263f3a32="" href="https://juejin.im/book/5c90640c5188252d7941f5bb/section/5c9065385188252da6320022" target="_blank" rel="" class="rank"><img data-v-6d94a6ea="" src="./程序员必备高级技术之函数调用栈_files/lv-2.f597b88.svg" alt="lv-2"></a></a><div data-v-fa2339b8="" class="meta-box"><time data-v-fa2339b8="" datetime="2019-07-04T00:21:27.490Z" title="Thu Jul 04 2019 08:21:27 GMT+0800 (中国标准时间)" class="time">2019年07月04日</time><span data-v-fa2339b8="" class="views-count">阅读 853</span><!----></div></div><button data-v-5789daef="" data-v-fa2339b8="" class="follow-button follow">关注</button></div><!----><h1 data-v-fa2339b8="" class="article-title">程序员必备高级技术之函数调用栈</h1><div data-v-fa2339b8="" data-id="5d1d4687e51d45590a445b99" itemprop="articleBody" class="article-content"><p>大家都知道函数调用是通过栈来实现的，而且知道在栈中存放着该函数的局部变量。但是对于栈的实现细节可能不一定清楚。本文将介绍一下在Linux平台下函数栈是如何实现的。有些同学可能觉得没必要了解这么深入，其实非也。<strong>根据本号多年的经验，了解系统深层次的原理对分析疑难问题有很好的帮助</strong>。
</p><figure><img alt="图0 函数栈" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5ac6ad57dbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="555" data-height="290" src="./程序员必备高级技术之函数调用栈_files/16bba5ac6ad57dbe"><figcaption></figcaption></figure><p></p>
<p>就像<strong>熟悉抓包是解决网络通信问题的高级武器一样</strong>，熟悉函数调用栈则是分析程序内存问题的高级武器。本文以Linux 64位操作系统下C语言开发为例，介绍应用程序调用栈的实现原理，并通过一个实例和GDB工具具体分析一下某个程序的调用栈内容。在介绍具体的调用栈之前，我们先介绍一些基础知识，这些知识是理解后续函数调用栈的基础。</p>
<h1 class="heading" data-id="heading-0">X86 CPU的寄存器</h1>
<p>CPU的寄存器是需要了解的基础知识，这是因为在X64体系中函数的参数是通过寄存器传递的。如图1是X86 CPU寄存器的列表及功能简要说明。
</p><figure><img alt="图1 Intel X86 CPU寄存器用途" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5ac6b6b0c8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="700" data-height="502" src="./程序员必备高级技术之函数调用栈_files/16bba5ac6b6b0c8e"><figcaption></figcaption></figure>
我们知道Intel的CPU在设计的时候都是向前兼容的，也就是在新一代的CPU上可以运行老一代CPU上的编译的程序。为了保证兼容性，新一代CPU保留了老一代寄存器的别名。以16位寄存器AX为例，AL表示低8位，AH表示高8位。而32位CPU问世之后，通过名为EAX的寄存器表示32位寄存器，AX仍然保留。以此类推，RAX表示一个64位寄存器。
<figure><img alt="图2 不同的寄存器名称" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5ac6c53b047?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="700" data-height="142" src="./程序员必备高级技术之函数调用栈_files/16bba5ac6c53b047"><figcaption></figcaption></figure><p></p>
<h1 class="heading" data-id="heading-1">应用程序的地址空间</h1>
<p><strong>操作系统通过虚拟内存的方式为所有应用程序提供了统一的内存映射地址</strong>。如图3所示，从上到下分别是用户栈、共享库内存、运行时堆和代码段。当然这个是一个大概的分段，实际分段比这个可能稍微复杂一些，但整个格局没有大变化。
</p><figure><img alt="图3 应用程序的地址空间" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5ac6b5c6911?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="360" data-height="579" src="./程序员必备高级技术之函数调用栈_files/16bba5ac6b5c6911"><figcaption></figcaption></figure>
从图中可以看出用户栈是从上往下生长的。也就是用户栈会先占用高地址的空间，然后占用低地址空间。目前我们可以大体上有个了解即可，后面我们在详细分析用户栈的细节。<p></p>
<h1 class="heading" data-id="heading-2">函数调用及汇编指令</h1>
<p><strong>为了理解函数调用栈的细节，有必要了解一下汇编程序中函数调用的实现</strong>。函数的调用主要分为2部分，一个是<strong>调用</strong>，另外一个是<strong>返回</strong>。在汇编语言中函数调用是通过<code>call</code>指令完成的，返回则是通过<code>ret</code>指令。
汇编语言的call指令相当于执行了2步操作，分别是，1）将当前的IP或CS和IP压入栈中； 2）跳转，类似与jmp指令。同样，ret指令也分2步，分别是，1）将栈中的地址弹出到IP寄存器；2）跳转执行后续指令。这个基本上就是函数调用的原理。
除了在代码间的跳动外，函数的调用往往还需要传递一个参数，而处理完成后还可能有返回值。这些数据的传递都是通过寄存器进行的。在函数调用之前通过上文介绍的寄存器存储参数，函数返回之前通过RAX寄存器（32位系统为EAX）存储返回结果。
另外一个比较重要的知识点是函数调用过程中与堆栈相关的寄存器RSP和RBP，两个寄存器主要实现对栈位置的记录，具体作用如下：
<strong>RSP：栈指针寄存器</strong>(reextended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。
<strong>RBP：基址指针寄存器</strong>(reextended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p>
<blockquote>
<p>寄存器的名称跟体系结构是相关的，本文是64位系统，因此寄存器是RSP和RBP。如果是32位系统则寄存器的名称为ESP和EBP。</p>
</blockquote>
<h1 class="heading" data-id="heading-3">应用程序调用栈</h1>
<p>我们先从整体上来看一下函数调用栈的主要内容，如图4所示。在函数栈中主要包括<strong>函数参数表、局部变量表、栈的基址和函数返回地址</strong>。<strong>这里栈的基址是上一个栈帧的基址</strong>，因为在本函数中需要使用该基址访问栈中的内容，因此需要首先将上一个栈帧中的基址压栈。
</p><figure><img alt="图4 函数调用栈概览" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5ac702dd3b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="545" data-height="643" src="./程序员必备高级技术之函数调用栈_files/16bba5ac702dd3b2"><figcaption></figcaption></figure><p></p>
<p>为了便于理解，我们以一个具体的程序作为示例。本程序非常简单，主要是模拟了多个函数的函数调用关系和参数传递。另外，在函数func_2中定义了2个形参，以模拟多参数传递的过程。
</p><figure><img alt="图5" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5ac9f9d8634?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="795" data-height="817" src="./程序员必备高级技术之函数调用栈_files/16bba5ac9f9d8634"><figcaption></figcaption></figure>
在本示例中，main函数调用func_1函数。我们从main函数开始分析，可以先看一下右侧的C语言代码。<strong>首先是函数参数的准备过程。<strong>在main函数调用func_1时依次传入的参数为1、2、3和4+g，其中最后一个参数是需要计算的。按照红色方框的虚线，我们可以看到对应的汇编程序，在汇编程序中首先处理最后一个参数，然后是倒数第二个，以此类推（函数参数的处理顺序在日常开发中是需要注意的内容重点）。同时，我们看到存储参数的寄存器名称与前文是一致。
<strong>当准备完参数之后，就是调用func_1函数</strong>，这个在汇编语言中就是<code>call func_1</code>这一行。虽然只是一行汇编指令，但其实内部做了一些事情，这个我们在前文介绍call指令的时候有所介绍，大家可以参考一下前文。
之后就进入<code>func_1</code>函数的处理逻辑。最一开始是<code>pushq %rbp</code>汇编程序，这句指令的作用是将RBP压入函数栈中。这句压栈及后面的更新RBP的值（moveq %rsp, %rbp）是构建本函数的栈帧头，后续对本栈帧的内容的访问都是通过帧头（RBP）进行的。接下来是对参数压栈的过程和局部变量初始化的过程，具体分布参考图5中的绿色方框和红色方框。
<strong>完成函数内的运算后，最后将运算结果放入寄存器EAX中</strong>，然后调用指令leave和ret。这里面需要说明的是leave指令，该指令相当于下面两条汇编指令。可以对比一下函数入口的汇编指令，其实两者是对称的。leave指令将本帧的</strong>栈基址</strong>赋值给栈指针（图6中步骤2），然后将其中的内容弹出到RBP中（图6中步骤3）。其实就是RBP指向上一个帧（调用者）的栈帧，也即是一个复原的过程。<p></p>
<pre><code class="hljs bash copyable" lang="bash">movl %ebp %esp
popl %ebp
<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="图6 函数返回示意图" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5acbbf31fad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="527" data-height="523" src="./程序员必备高级技术之函数调用栈_files/16bba5acbbf31fad"><figcaption></figcaption></figure>
这样，函数返回后寄存器RBP和RSP从被调用者的栈帧切换到了调用者的栈帧。<p></p>
<h1 class="heading" data-id="heading-4">通过GDB分析函数调用栈</h1>
<p>上面是通过反汇编的方式分析函数的调用栈和栈帧情况。我们还可以通过gdb动态的分析函数栈和栈帧的使用情况。我们依然通过main函数调用func_1函数为例来分析。我们这里在函数func_1的入口处设置一个单点，然后运行程序，程序停止在断点处。如图7是我们逐步执行是函数栈的变化过程，具体细节我们这里就不再赘述，大家可以实际操作一下。
</p><figure><img alt="图7 函数栈变化过程" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2019/7/4/16bba5acf7a8757c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="678" data-height="752" src="./程序员必备高级技术之函数调用栈_files/16bba5acf7a8757c"><figcaption></figcaption></figure><p></p>
<p>本文的目的是让大家对函数调用栈有个整体的了解，这样对以后程序的疑难杂症就有更多的解决思路。因为在实际生产环境中与栈相关的问题也是比较多的，比如局部变量太多导致的栈溢出，或者踩内存问题引起的栈破坏等等。因此，了解了函数栈的原理，在遇到所谓的莫名其妙问题的时候就会有新的思路。<strong>往往很多问题不是问题本身莫名其妙，而是我们的知识储备不够，自己感觉莫名其妙而已。</strong></p>
</div></article><!----><!----><div data-v-0d823780="" data-v-fa2339b8="" class="comment-list-box" id="comment-box" data-v-6fdc8784=""><div data-v-0d823780="" class="title">评论</div><div data-v-155bc796="" data-v-0d823780="" class="comment-form comment-form"><div data-v-155bc796="" class="avatar-box"><div data-v-95ddf8f6="" data-v-39db9419="" data-v-155bc796="" data-src="https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg" class="lazy avatar avatar loaded" style="background-image: url(&quot;https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg&quot;);"></div></div><div data-v-155bc796="" class="form-box"><div data-v-155bc796="" class="input-box"><div data-v-cc6aae16="" data-v-155bc796="" class="auth-card"><!----><div data-v-155bc796="" data-v-cc6aae16="" contenteditable="true" spellcheck="false" placeholder="输入评论..." class="rich-input empty"><br data-v-155bc796="" data-v-cc6aae16=""></div></div><!----></div><!----></div><input data-v-155bc796="" type="file" class="hidden"></div><!----><!----></div></div><!----><div data-v-0a49d917="" data-v-fa2339b8="" class="image-viewer-box" data-v-6fdc8784=""><!----></div><!----></div></main></div><!----></div>
      
      
      
      <script type="text/javascript" src="./程序员必备高级技术之函数调用栈_files/runtime.cc2b750c14e4e98c0e3a.js"></script><script type="text/javascript" src="./程序员必备高级技术之函数调用栈_files/0.0b214b1cb6731ce0f8d8.js"></script><script type="text/javascript" src="./程序员必备高级技术之函数调用栈_files/1.63ca4ab7fc5bd9c1cbc0.js"></script>
    <div><div style="display: none; position: fixed; top: 30px; width: auto; max-width: 100%; text-align: center; left: 50%; transform: translateX(-50%); z-index: 99999999;"><div style="display: inline-block; font-size: 14px; font-weight: bold; border: 1px solid rgb(240, 195, 109); background-color: rgb(249, 237, 190); padding: 0px 10px; border-radius: 2px; box-shadow: rgba(0, 0, 0, 0.2) 0px 2px 4px;"></div></div></div></body></html>